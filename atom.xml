<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ashen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/StudentWan/hexo-ashen-theme/"/>
  <updated>2019-01-13T08:04:37.059Z</updated>
  <id>https://github.com/StudentWan/hexo-ashen-theme/</id>
  
  <author>
    <name>ashen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Word Ladder II学习深搜&amp;广搜</title>
    <link href="https://github.com/StudentWan/hexo-ashen-theme/2019/01/13/%E4%BB%8EWord%20Ladder%20II%E5%AD%A6%E4%B9%A0%E6%B7%B1%E6%90%9C&amp;%E5%B9%BF%E6%90%9C/"/>
    <id>https://github.com/StudentWan/hexo-ashen-theme/2019/01/13/从Word Ladder II学习深搜&amp;广搜/</id>
    <published>2019-01-13T02:37:56.000Z</published>
    <updated>2019-01-13T08:04:37.059Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode上有这样一道题：<a href="https://leetcode.com/problems/word-ladder-ii/description/" target="_blank" rel="noopener">Q126. Word Ladder II</a></p><p>这是一道Hard难度的题目，通过率也不高，但是很好的结合了深度优先搜索和广度优先搜索，我希望用这道题目来总结一下深搜&amp;广搜的思想。</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p><blockquote><p>1、Only one letter can be changed at a time</p></blockquote><blockquote><p>2、Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</p></blockquote><p>For example,</p><p>Given:</p><p>beginWord = <code>&quot;hit&quot;</code></p><p>endWord = <code>&quot;cog&quot;</code></p><p>wordList = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Return</p><pre><code>[    [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],    [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><p>Note:</p><blockquote><p>Return an empty list if there is no such transformation sequence.</p><p>All words have the same length.</p><p>All words contain only lowercase alphabetic characters.</p><p>You may assume no duplicates in the word list.</p><p>You may assume beginWord and endWord are non-empty and are not the same.</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>既然本文的想法就是希望通过此题来总结深搜&amp;广搜，所以我们的思路也自然是将深搜和广搜结合起来解题，当然，能够结合起来也是有原因的，我们需要知道深搜和广搜，分别适合哪种情况的求解。</p><blockquote><p>深度优先搜索：适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去。</p></blockquote><blockquote><p>广度优先搜索：层级遍历，适用于那些最小或最短问题的求解，核心思想是通过队列或优先队列保存状态，优先选择看似最优的状态进行扩展，以达到最先扩展到目标节点的目的。</p></blockquote><p>在本题中，我们既要求得所有的转移序列，又要得到其中最短的序列的集合。</p><p>在我最初的解法中，只使用了深度优先搜索，求得所有的转移序列，然后在其中寻找最短的，但是这样的解法，会造成深度遍历的冗余，和后续没有必要的筛选工作，因此也TLE了。</p><p>那么何不先进行广度优先搜索，构造出图和最短路径，然后再进行深度优先搜索，在图和最短路径的约束下递归得到所有的可能呢？</p><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>于是，我们可以这样完成入口函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123;</span><br><span class="line"><span class="comment">// Just means wordList, but as a set</span></span><br><span class="line">HashSet&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;String&gt;(wordList);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;(); <span class="comment">// Neighbor for every node</span></span><br><span class="line">HashMap&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();<span class="comment">// Distance of every node from the start node</span></span><br><span class="line">ArrayList&lt;String&gt; solution = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">dict.add(start);</span><br><span class="line">solution.add(start);</span><br><span class="line">bfs(start, end, dict, nodeNeighbors, distance);</span><br><span class="line">dfs(start, end, dict, nodeNeighbors, distance, solution, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以一个HashSet:dict来保存wordList。</p><p>最后返回的结果用List:res保存。</p><p>以一个HashMap:nodeNeighbors保存每一个节点的邻接点，以构成图，在bfs中求出来。</p><p>以一个HashMap:distance保存到每一个节点的最短路径，在bfs中求出来。</p><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>bfs的解题方法一般是如下的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BFS()</span><br><span class="line">&#123;</span><br><span class="line">  输入起始点；</span><br><span class="line">  初始化所有顶点标记；</span><br><span class="line">  初始化一个队列queue并将起始点放入队列；</span><br><span class="line"></span><br><span class="line">  while（queue不为空）</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    从队列中删除一个顶点s并标记为已遍历； //表示遍历了s</span><br><span class="line">    将s邻接的所有还没遍历的点加入队列；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS: Trace every node's distance from the start node (level by level).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化已经在入口函数中完成了。</span></span><br><span class="line"><span class="keyword">for</span> (String str : dict) &#123;</span><br><span class="line">nodeNeighbors.put(str, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue.offer(start);</span><br><span class="line">distance.put(start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> count = queue.size();</span><br><span class="line"><span class="keyword">boolean</span> foundEnd = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">String cur = queue.poll();</span><br><span class="line"><span class="keyword">int</span> curDistance = distance.get(cur);</span><br><span class="line">ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">nodeNeighbors.get(cur).add(neighbor);</span><br><span class="line"><span class="keyword">if</span> (!distance.containsKey(neighbor)) &#123; <span class="comment">//Check if visited</span></span><br><span class="line">distance.put(neighbor, curDistance + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (end.equals(neighbor))</span><br><span class="line">foundEnd = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">queue.offer(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foundEnd)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all next level nodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">chs[i] = ch;</span><br><span class="line"><span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">res.add(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">chs[i] = old_ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们使用bfs的目的就达到了，我们利用层级遍历构造了nodeNeighbors，以此作为dfs中需要用到的图，并构造了到达每个节点的最短路径的distance。</p><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>dfs的解题方法一般是如下的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DFS() &#123;</span><br><span class="line">  if(到达目标递归深度) &#123;</span><br><span class="line">    判断当前状态是否为解？-&gt;添加当前状态到解集合</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  for(i in 所有可能情况) &#123;</span><br><span class="line">    if(i还未进行搜索) &#123;</span><br><span class="line">      标记i已搜索</span><br><span class="line">      dfs()</span><br><span class="line">      还原现场（标记i未搜索）</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs需要注意的点是：参数记录的状态、过滤掉不可能的状态、状态的保存和还原。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS: output all paths with the shortest distance</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (end.equals(cur)) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(solution));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String next : nodeNeighbors.get(cur)) &#123;</span><br><span class="line"><span class="keyword">if</span> (distance.get(next) == distance.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">solution.add(next);</span><br><span class="line">dfs(next, end, dict, nodeNeighbors, distance, solution, res);</span><br><span class="line">solution.remove(solution.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，此处的判断：<code>if (distance.get(next) == distance.get(cur) + 1)</code>，用来过滤掉非最短路径的情况，当前者小于后者时，这样的路径不是最短的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leetcode上有这样一道题：&lt;a href=&quot;https://leetcode.com/problems/word-ladder-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Q126. Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一道Hard难度的题目，通过率也不高，但是很好的结合了深度优先搜索和广度优先搜索，我希望用这道题目来总结一下深搜&amp;amp;广搜的思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://github.com/StudentWan/hexo-ashen-theme/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>断点调试的学习与思考-以一个NodeJS程序调试为例</title>
    <link href="https://github.com/StudentWan/hexo-ashen-theme/2018/12/28/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83-%E4%BB%A5%E4%B8%80%E4%B8%AANodeJS%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%B8%BA%E4%BE%8B/"/>
    <id>https://github.com/StudentWan/hexo-ashen-theme/2018/12/28/断点调试的学习与思考-以一个NodeJS程序调试为例/</id>
    <published>2018-12-28T02:45:07.000Z</published>
    <updated>2019-01-13T03:53:30.736Z</updated>
    
    <content type="html"><![CDATA[<p>之前在调试JS代码的时候，经常使用的调试方式就是用<code>console.log</code>跟踪代码执行来确定问题点，但是使用<code>console.log</code>进行调试存在一些问题：</p><pre><code>1. 污染代码结构2. 调试第三方库的时候无能为力</code></pre><p>而使用断点调试的原理是根据函数的调用栈信息来确定问题的所在，相比于<code>console.log</code>调试，断点调试针对上述两种情况拥有更好的表现。</p><p>由于在周五的工作中遇到了需要针对NodeJS程序进行断点调试的实例，因此我将结合当时使用情况来讲解一下我对断点调试的学习、理解和一些思考。</p><p>我使用的编辑器是Visual Studio Code，在讲述相关知识的时候会以VS Code为基础，但在其他的编辑器中情况应该是大同小异的。</p><a id="more"></a><h3 id="断点调试基本知识"><a href="#断点调试基本知识" class="headerlink" title="断点调试基本知识"></a>断点调试基本知识</h3><p>首先是基本界面：</p><p><img src="http://p20zi8dae.bkt.clouddn.com/ui20180610.png" alt="UI界面"></p><p>下面逐一讲解：</p><pre><code>1. 变量信息：表示在当前的调用栈下的局部变量、闭包和全局变量，我们在调试的过程中可以通过观察变量的变化来追踪程序的问题2. 调用堆栈信息：这个比较好理解，表示当前所处的调用栈3. 已打的断点：表示在调试过程中你已经打过的断点4. 调试选项配置：可以在这里设置调试程序时的命令和参数5. 断点：你当前看到的断点6. log和异常信息：log和异常信息会显示在调试控制台7. 调试操作栏：调试过程中需要使用到的一些操作的集合，下文将逐一讲解</code></pre><p>然后讲解一下调试操作栏中最重要的三个选项：</p><pre><code>1. 单步跳过：指直接跳过当前语句的执行流程，叫程序的运行阶段推动到下一条应该执行语句，可以被断点打断。我们可以使用单步跳过来跳过一些对于定位问题没有帮助的函数执行2. 单步调试：指进入当前函数的调用中，观察函数的执行细节。通过单步调试，我们可以观察到函数的执行细节并追踪到函数执行到某一步时的变量信息等重要信息3. 单步跳出：指跳出当前函数的执行，叫程序的运行阶段推动到下一跳应该执行语句，可以被断点打断。我们可以用单步跳出配合单步调试来更加细粒度的控制程序的执行</code></pre><p>掌握了基本知识基本就可以进行断点调试了，但是在调试NodeJS程序时<strong><em>有一点需要注意：</em></strong>针对<code>.js</code>后缀的文件，NodeJS是不原生支持ES Modules的，需要使用babel进行转译，这会造成我们实际调试的代码并不是我们书写的源代码，从而导致得不到相关信息。</p><p><strong><em>解决办法：</em></strong>如果在代码中使用了ES Modules的语法，将它改成CommonJS Modules，并去掉相关的转译babel。2018/08/19补充:或使用sourcemap。</p><h3 id="实例，一个NodeJS程序的断点调试"><a href="#实例，一个NodeJS程序的断点调试" class="headerlink" title="实例，一个NodeJS程序的断点调试"></a>实例，一个NodeJS程序的断点调试</h3><p>在周五我遇到的问题是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actual = transformFileSync(actualPath, &#123;</span><br><span class="line">  babelrc: <span class="literal">false</span>,</span><br><span class="line">  plugins: [<span class="string">'../../../src/index.js'</span>]</span><br><span class="line">&#125;).code;</span><br></pre></td></tr></table></figure><p>在看到这段代码的时候师兄问了我一个问题：这个程序是怎么通过你<code>plugins</code>属性提供的字符串来把你需要的index.js文件加载进来的？</p><p>追踪到<code>transformFileSync</code>函数的定义，发现它是在第三方模块babel-core中引入的，显然，这个问题我们是无法用<code>console.log</code>来回答的。</p><p>于是就开始了断点调试的过程，首先在这一行打上断点，然后开始单步调试：</p><p><img src="http://p20zi8dae.bkt.clouddn.com/break_first20180610.png" alt="第一个断点"></p><p>首先我选择通过结合上文提到的三种操作方式跑通一次程序，借此发现加载index.js文件的时候有哪些变量发生了怎样的变化。我发现，在变量信息中，一个<code>plugins</code>属性发生了变化：</p><p><img src="http://p20zi8dae.bkt.clouddn.com/plugin_120180610.png" alt="plugins状态1"></p><p><img src="http://p20zi8dae.bkt.clouddn.com/plugin-220180610.png" alt="plugins状态2"></p><p>在仔细分析了这个属性和以及它和正在调试的程序的关联后，我确定就是在这个属性变化的时候真正引入了index.js。</p><p>接下来要做的事就是通过单步调试，逐步缩窄范围，最后确定引入index.js文件的具体位置。</p><p>下面以缩窄范围的第一步举例：</p><p>首先通过单步调试，我发现程序运行到以下代码的第一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> _file2.default(opts, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> file.wrap(code, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  file.addCode(code);</span><br><span class="line">  file.parseCode(code);</span><br><span class="line">  <span class="keyword">return</span> file.transform();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而在单步调试和单步跳出<figure class="highlight plain"><figcaption><span>file </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```这行代码以后，我发现`plugins`属性发生了上文提到的变化，这说明，这次index.js文件的加载一定是发生在```new _file2.default(..., ...)```这个函数的执行过程中，于是我就可以把断点定在这个函数的第一行，然后单步往后调试：</span><br><span class="line"></span><br><span class="line">![第一次缩窄范围](http://p20zi8dae.bkt.clouddn.com/narrow_first20180610.png)</span><br><span class="line"></span><br><span class="line">经过几次重复上述的过程，最终定位到了加载index.js文件的代码：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">if (pluginLoc) &#123;</span><br><span class="line">  plugin = require(pluginLoc);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  throw new ReferenceError(messages.get(&quot;pluginUnknown&quot;, plugin, loc, i, dirname));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h3><p>我在缩窄范围以定位问题的过程中一共打了6个断点，但是师兄给我演示时候只打了3个，这还是由于我对NodeJS和断点调试的熟练程度不够，以后多学习、运用，应该可以不断提升。</p><p>下面谈一点思考：</p><p>在这次学习断点调试的过程中，学到了不同的技术有不同适合的场景，比如有些问题可能通过log更好定位，另一些则用断点调试可能会更好。</p><h4 id="2018-08-19补充：绝大部分问题用debugger都能更好的解决"><a href="#2018-08-19补充：绝大部分问题用debugger都能更好的解决" class="headerlink" title="2018/08/19补充：绝大部分问题用debugger都能更好的解决"></a>2018/08/19补充：绝大部分问题用debugger都能更好的解决</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在调试JS代码的时候，经常使用的调试方式就是用&lt;code&gt;console.log&lt;/code&gt;跟踪代码执行来确定问题点，但是使用&lt;code&gt;console.log&lt;/code&gt;进行调试存在一些问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 污染代码结构
2. 调试第三方库的时候无能为力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而使用断点调试的原理是根据函数的调用栈信息来确定问题的所在，相比于&lt;code&gt;console.log&lt;/code&gt;调试，断点调试针对上述两种情况拥有更好的表现。&lt;/p&gt;
&lt;p&gt;由于在周五的工作中遇到了需要针对NodeJS程序进行断点调试的实例，因此我将结合当时使用情况来讲解一下我对断点调试的学习、理解和一些思考。&lt;/p&gt;
&lt;p&gt;我使用的编辑器是Visual Studio Code，在讲述相关知识的时候会以VS Code为基础，但在其他的编辑器中情况应该是大同小异的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="https://github.com/StudentWan/hexo-ashen-theme/tags/NodeJS/"/>
    
      <category term="Debug" scheme="https://github.com/StudentWan/hexo-ashen-theme/tags/Debug/"/>
    
  </entry>
  
</feed>
